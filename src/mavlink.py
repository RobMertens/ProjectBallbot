'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: robot_messages.xml,microos_messages.xml

Note: this file has been auto-generated. DO NOT EDIT
'''

import struct, array, time, json
from generator.mavcrc import x25crc

WIRE_PROTOCOL_VERSION = "1.0"


# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10


class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId

    def pack(self):
        return struct.pack('BBBBBB', 254, self.mlen, self.seq,
                          self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name

    def get_msgbuf(self):
        if isinstance(self._msgbuf, str):
            return self._msgbuf
        return self._msgbuf.tostring()

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = getattr(self, a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret

    def to_dict(self):
        d = dict({})
        d['mavpackettype'] = self._type
        for a in self._fieldnames:
          d[a] = getattr(self, a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def pack(self, mav, crc_extra, payload):
        self._payload = payload
        self._header  = MAVLink_header(self._header.msgId, len(payload), mav.seq,
                                       mav.srcSystem, mav.srcComponent)
        self._msgbuf = self._header.pack() + payload
        crc = x25crc(self._msgbuf[1:])
        if True: # using CRC extra
            crc.accumulate(chr(crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        return self._msgbuf


# enums

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_POSE = 50
MAVLINK_MSG_ID_ATTITUDE = 51
MAVLINK_MSG_ID_VELOCITY = 52
MAVLINK_MSG_ID_POSITION = 53
MAVLINK_MSG_ID_ATTITUDE_CMD = 54
MAVLINK_MSG_ID_VELOCITY_CMD = 55
MAVLINK_MSG_ID_POSITION_CMD = 56
MAVLINK_MSG_ID_RADAR_CLOUD = 70
MAVLINK_MSG_ID_RADAR_LINE = 71
MAVLINK_MSG_ID_SIGNAL_SWEPTSINE = 80
MAVLINK_MSG_ID_SIGNAL_MULTISINE = 81
MAVLINK_MSG_ID_SIGNAL_STEPPEDSINE = 82
MAVLINK_MSG_ID_CHANNEL_IO = 102
MAVLINK_MSG_ID_CHANNEL_IO_INFO = 103
MAVLINK_MSG_ID_HEARTBEAT = 0
MAVLINK_MSG_ID_THREAD_INFO = 1
MAVLINK_MSG_ID_PARTITION = 2
MAVLINK_MSG_ID_GPIO = 3
MAVLINK_MSG_ID_EVENT = 4
MAVLINK_MSG_ID_PRINT = 5

class MAVLink_pose_message(MAVLink_message):
        '''
        Robot pose information.
        '''
        def __init__(self, x, y, z, roll, pitch, yaw):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POSE, 'POSE')
                self._fieldnames = ['x', 'y', 'z', 'roll', 'pitch', 'yaw']
                self.x = x
                self.y = y
                self.z = z
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 97, struct.pack('<iiihhh', self.x, self.y, self.z, self.roll, self.pitch, self.yaw))

class MAVLink_attitude_message(MAVLink_message):
        '''
        Robot attitude information.
        '''
        def __init__(self, time, roll, pitch, yaw, roll_cmd, pitch_cmd, yaw_cmd, roll_act, pitch_act, yaw_act):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_ATTITUDE, 'ATTITUDE')
                self._fieldnames = ['time', 'roll', 'pitch', 'yaw', 'roll_cmd', 'pitch_cmd', 'yaw_cmd', 'roll_act', 'pitch_act', 'yaw_act']
                self.time = time
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.roll_cmd = roll_cmd
                self.pitch_cmd = pitch_cmd
                self.yaw_cmd = yaw_cmd
                self.roll_act = roll_act
                self.pitch_act = pitch_act
                self.yaw_act = yaw_act

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 194, struct.pack('<Ihhhhhhhhh', self.time, self.roll, self.pitch, self.yaw, self.roll_cmd, self.pitch_cmd, self.yaw_cmd, self.roll_act, self.pitch_act, self.yaw_act))

class MAVLink_velocity_message(MAVLink_message):
        '''
        Robot velocity information.
        '''
        def __init__(self, time, vx, vy, vz, vx_cmd, vy_cmd, vz_cmd, vx_act, vy_act, vz_act):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_VELOCITY, 'VELOCITY')
                self._fieldnames = ['time', 'vx', 'vy', 'vz', 'vx_cmd', 'vy_cmd', 'vz_cmd', 'vx_act', 'vy_act', 'vz_act']
                self.time = time
                self.vx = vx
                self.vy = vy
                self.vz = vz
                self.vx_cmd = vx_cmd
                self.vy_cmd = vy_cmd
                self.vz_cmd = vz_cmd
                self.vx_act = vx_act
                self.vy_act = vy_act
                self.vz_act = vz_act

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 13, struct.pack('<Ihhhhhhhhh', self.time, self.vx, self.vy, self.vz, self.vx_cmd, self.vy_cmd, self.vz_cmd, self.vx_act, self.vy_act, self.vz_act))

class MAVLink_position_message(MAVLink_message):
        '''
        Robot position information.
        '''
        def __init__(self, time, x, y, z, x_cmd, y_cmd, z_cmd, x_act, y_act, z_act):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POSITION, 'POSITION')
                self._fieldnames = ['time', 'x', 'y', 'z', 'x_cmd', 'y_cmd', 'z_cmd', 'x_act', 'y_act', 'z_act']
                self.time = time
                self.x = x
                self.y = y
                self.z = z
                self.x_cmd = x_cmd
                self.y_cmd = y_cmd
                self.z_cmd = z_cmd
                self.x_act = x_act
                self.y_act = y_act
                self.z_act = z_act

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 171, struct.pack('<Iiiiiiihhh', self.time, self.x, self.y, self.z, self.x_cmd, self.y_cmd, self.z_cmd, self.x_act, self.y_act, self.z_act))

class MAVLink_attitude_cmd_message(MAVLink_message):
        '''
        Robot attitude command/reference.
        '''
        def __init__(self, roll, pitch, yaw, rollFF, pitchFF, yawFF):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_ATTITUDE_CMD, 'ATTITUDE_CMD')
                self._fieldnames = ['roll', 'pitch', 'yaw', 'rollFF', 'pitchFF', 'yawFF']
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.rollFF = rollFF
                self.pitchFF = pitchFF
                self.yawFF = yawFF

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 19, struct.pack('<hhhhhh', self.roll, self.pitch, self.yaw, self.rollFF, self.pitchFF, self.yawFF))

class MAVLink_velocity_cmd_message(MAVLink_message):
        '''
        Robot velocity command/reference.
        '''
        def __init__(self, vx, vy, vz, vxFF, vyFF, vzFF):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_VELOCITY_CMD, 'VELOCITY_CMD')
                self._fieldnames = ['vx', 'vy', 'vz', 'vxFF', 'vyFF', 'vzFF']
                self.vx = vx
                self.vy = vy
                self.vz = vz
                self.vxFF = vxFF
                self.vyFF = vyFF
                self.vzFF = vzFF

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 172, struct.pack('<hhhhhh', self.vx, self.vy, self.vz, self.vxFF, self.vyFF, self.vzFF))

class MAVLink_position_cmd_message(MAVLink_message):
        '''
        Robot position command/reference.
        '''
        def __init__(self, x, y, z, xFF, yFF, zFF):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POSITION_CMD, 'POSITION_CMD')
                self._fieldnames = ['x', 'y', 'z', 'xFF', 'yFF', 'zFF']
                self.x = x
                self.y = y
                self.z = z
                self.xFF = xFF
                self.yFF = yFF
                self.zFF = zFF

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 122, struct.pack('<iiihhh', self.x, self.y, self.z, self.xFF, self.yFF, self.zFF))

class MAVLink_radar_cloud_message(MAVLink_message):
        '''
        Point cloud information.
        '''
        def __init__(self, x, y):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_RADAR_CLOUD, 'RADAR_CLOUD')
                self._fieldnames = ['x', 'y']
                self.x = x
                self.y = y

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 158, struct.pack('<6i6i', self.x[0], self.x[1], self.x[2], self.x[3], self.x[4], self.x[5], self.y[0], self.y[1], self.y[2], self.y[3], self.y[4], self.y[5]))

class MAVLink_radar_line_message(MAVLink_message):
        '''
        Line feature.
        '''
        def __init__(self, x, y):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_RADAR_LINE, 'RADAR_LINE')
                self._fieldnames = ['x', 'y']
                self.x = x
                self.y = y

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 230, struct.pack('<2i2i', self.x[0], self.x[1], self.y[0], self.y[1]))

class MAVLink_signal_sweptsine_message(MAVLink_message):
        '''
        Message to set sweptsine excitation
        '''
        def __init__(self, channels, fmin, fmax, period, amplitude):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_SIGNAL_SWEPTSINE, 'SIGNAL_SWEPTSINE')
                self._fieldnames = ['channels', 'fmin', 'fmax', 'period', 'amplitude']
                self.channels = channels
                self.fmin = fmin
                self.fmax = fmax
                self.period = period
                self.amplitude = amplitude

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 41, struct.pack('<ffffH', self.fmin, self.fmax, self.period, self.amplitude, self.channels))

class MAVLink_signal_multisine_message(MAVLink_message):
        '''
        Message to set multisine excitation
        '''
        def __init__(self, channels, id, amplitude):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_SIGNAL_MULTISINE, 'SIGNAL_MULTISINE')
                self._fieldnames = ['channels', 'id', 'amplitude']
                self.channels = channels
                self.id = id
                self.amplitude = amplitude

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 237, struct.pack('<fHB', self.amplitude, self.channels, self.id))

class MAVLink_signal_steppedsine_message(MAVLink_message):
        '''
        Message to set stepped sine excitation
        '''
        def __init__(self, channels, fmin, fmax, period, stepsize, amplitude):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_SIGNAL_STEPPEDSINE, 'SIGNAL_STEPPEDSINE')
                self._fieldnames = ['channels', 'fmin', 'fmax', 'period', 'stepsize', 'amplitude']
                self.channels = channels
                self.fmin = fmin
                self.fmax = fmax
                self.period = period
                self.stepsize = stepsize
                self.amplitude = amplitude

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 15, struct.pack('<ffffHB', self.fmin, self.fmax, self.stepsize, self.amplitude, self.channels, self.period))

class MAVLink_channel_io_message(MAVLink_message):
        '''
        Message to send input-output channel information to the ground
        station
        '''
        def __init__(self, time, sync, input, output):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_CHANNEL_IO, 'CHANNEL_IO')
                self._fieldnames = ['time', 'sync', 'input', 'output']
                self.time = time
                self.sync = sync
                self.input = input
                self.output = output

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 156, struct.pack('<I6f6fB', self.time, self.input[0], self.input[1], self.input[2], self.input[3], self.input[4], self.input[5], self.output[0], self.output[1], self.output[2], self.output[3], self.output[4], self.output[5], self.sync))

class MAVLink_channel_io_info_message(MAVLink_message):
        '''
        Info regarding channel io
        '''
        def __init__(self, type, configuration, excitation, version, subversion):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_CHANNEL_IO_INFO, 'CHANNEL_IO_INFO')
                self._fieldnames = ['type', 'configuration', 'excitation', 'version', 'subversion']
                self.type = type
                self.configuration = configuration
                self.excitation = excitation
                self.version = version
                self.subversion = subversion

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 102, struct.pack('<BBBBB', self.type, self.configuration, self.excitation, self.version, self.subversion))

class MAVLink_heartbeat_message(MAVLink_message):
        '''
        The heartbeat message shows that a system is present and
        responding. The type of the MAV and Autopilot hardware allow
        the receiving system to treat further messages from this
        system appropriate (e.g. by laying out the user interface
        based on the autopilot).
        '''
        def __init__(self, type, time, data, mavlink_version):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_HEARTBEAT, 'HEARTBEAT')
                self._fieldnames = ['type', 'time', 'data', 'mavlink_version']
                self.type = type
                self.time = time
                self.data = data
                self.mavlink_version = mavlink_version

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 31, struct.pack('<IB8BB', self.time, self.type, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.mavlink_version))

class MAVLink_thread_info_message(MAVLink_message):
        '''
        Message to report the execution time of the threads up till
        moment t [us].
        '''
        def __init__(self, time, ID, priority, duration, latency, total_duration, total_latency, number_of_executions):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_THREAD_INFO, 'THREAD_INFO')
                self._fieldnames = ['time', 'ID', 'priority', 'duration', 'latency', 'total_duration', 'total_latency', 'number_of_executions']
                self.time = time
                self.ID = ID
                self.priority = priority
                self.duration = duration
                self.latency = latency
                self.total_duration = total_duration
                self.total_latency = total_latency
                self.number_of_executions = number_of_executions

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 215, struct.pack('<IIIIHHBB', self.time, self.total_duration, self.total_latency, self.number_of_executions, self.duration, self.latency, self.ID, self.priority))

class MAVLink_partition_message(MAVLink_message):
        '''
        Message to read the entire eeprom.
        '''
        def __init__(self, ID, index, size, togo, value):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_PARTITION, 'PARTITION')
                self._fieldnames = ['ID', 'index', 'size', 'togo', 'value']
                self.ID = ID
                self.index = index
                self.size = size
                self.togo = togo
                self.value = value

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 248, struct.pack('<HcBB32B', self.index, self.ID, self.size, self.togo, self.value[0], self.value[1], self.value[2], self.value[3], self.value[4], self.value[5], self.value[6], self.value[7], self.value[8], self.value[9], self.value[10], self.value[11], self.value[12], self.value[13], self.value[14], self.value[15], self.value[16], self.value[17], self.value[18], self.value[19], self.value[20], self.value[21], self.value[22], self.value[23], self.value[24], self.value[25], self.value[26], self.value[27], self.value[28], self.value[29], self.value[30], self.value[31]))

class MAVLink_gpio_message(MAVLink_message):
        '''
        Message to send debugging information
        '''
        def __init__(self, time, gpio_float, gpio_int):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_GPIO, 'GPIO')
                self._fieldnames = ['time', 'gpio_float', 'gpio_int']
                self.time = time
                self.gpio_float = gpio_float
                self.gpio_int = gpio_int

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 172, struct.pack('<I8f4i', self.time, self.gpio_float[0], self.gpio_float[1], self.gpio_float[2], self.gpio_float[3], self.gpio_float[4], self.gpio_float[5], self.gpio_float[6], self.gpio_float[7], self.gpio_int[0], self.gpio_int[1], self.gpio_int[2], self.gpio_int[3]))

class MAVLink_event_message(MAVLink_message):
        '''
        Message to send event information: can be external event from
        base or event on robot
        '''
        def __init__(self, type):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_EVENT, 'EVENT')
                self._fieldnames = ['type']
                self.type = type

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 133, struct.pack('<H', self.type))

class MAVLink_print_message(MAVLink_message):
        '''
        Message allowing short strings to be passed on.
        '''
        def __init__(self, text):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_PRINT, 'PRINT')
                self._fieldnames = ['text']
                self.text = text

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 107, struct.pack('<32s', self.text))


mavlink_map = {
        MAVLINK_MSG_ID_POSE : ( '<iiihhh', MAVLink_pose_message, [0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 1, 1], 97 ),
        MAVLINK_MSG_ID_ATTITUDE : ( '<Ihhhhhhhhh', MAVLink_attitude_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 194 ),
        MAVLINK_MSG_ID_VELOCITY : ( '<Ihhhhhhhhh', MAVLink_velocity_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 13 ),
        MAVLINK_MSG_ID_POSITION : ( '<Iiiiiiihhh', MAVLink_position_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 171 ),
        MAVLINK_MSG_ID_ATTITUDE_CMD : ( '<hhhhhh', MAVLink_attitude_cmd_message, [0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 1, 1], 19 ),
        MAVLINK_MSG_ID_VELOCITY_CMD : ( '<hhhhhh', MAVLink_velocity_cmd_message, [0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 1, 1], 172 ),
        MAVLINK_MSG_ID_POSITION_CMD : ( '<iiihhh', MAVLink_position_cmd_message, [0, 1, 2, 3, 4, 5], [1, 1, 1, 1, 1, 1], 122 ),
        MAVLINK_MSG_ID_RADAR_CLOUD : ( '<6i6i', MAVLink_radar_cloud_message, [0, 1], [6, 6], 158 ),
        MAVLINK_MSG_ID_RADAR_LINE : ( '<2i2i', MAVLink_radar_line_message, [0, 1], [2, 2], 230 ),
        MAVLINK_MSG_ID_SIGNAL_SWEPTSINE : ( '<ffffH', MAVLink_signal_sweptsine_message, [4, 0, 1, 2, 3], [1, 1, 1, 1, 1], 41 ),
        MAVLINK_MSG_ID_SIGNAL_MULTISINE : ( '<fHB', MAVLink_signal_multisine_message, [1, 2, 0], [1, 1, 1], 237 ),
        MAVLINK_MSG_ID_SIGNAL_STEPPEDSINE : ( '<ffffHB', MAVLink_signal_steppedsine_message, [4, 0, 1, 5, 2, 3], [1, 1, 1, 1, 1, 1], 15 ),
        MAVLINK_MSG_ID_CHANNEL_IO : ( '<I6f6fB', MAVLink_channel_io_message, [0, 3, 1, 2], [1, 6, 6, 1], 156 ),
        MAVLINK_MSG_ID_CHANNEL_IO_INFO : ( '<BBBBB', MAVLink_channel_io_info_message, [0, 1, 2, 3, 4], [1, 1, 1, 1, 1], 102 ),
        MAVLINK_MSG_ID_HEARTBEAT : ( '<IB8BB', MAVLink_heartbeat_message, [1, 0, 2, 3], [1, 1, 8, 1], 31 ),
        MAVLINK_MSG_ID_THREAD_INFO : ( '<IIIIHHBB', MAVLink_thread_info_message, [0, 6, 7, 4, 5, 1, 2, 3], [1, 1, 1, 1, 1, 1, 1, 1], 215 ),
        MAVLINK_MSG_ID_PARTITION : ( '<HcBB32B', MAVLink_partition_message, [1, 0, 2, 3, 4], [1, 1, 1, 1, 32], 248 ),
        MAVLINK_MSG_ID_GPIO : ( '<I8f4i', MAVLink_gpio_message, [0, 1, 2], [1, 8, 4], 172 ),
        MAVLINK_MSG_ID_EVENT : ( '<H', MAVLink_event_message, [0], [1], 133 ),
        MAVLINK_MSG_ID_PRINT : ( '<32s', MAVLink_print_message, [0], [1], 107 ),
}

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            Exception.__init__(self, msg)
            self.message = msg

class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data

        def __str__(self):
            '''Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
            return '%s {%s, data:%s}' % (self._type, self.reason, [('%x' % ord(i) if isinstance(i, str) else '%x' % i) for i in self.data])

class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, file, srcSystem=0, srcComponent=0):
                self.seq = 0
                self.file = file
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.send_callback = None
                self.send_callback_args = None
                self.send_callback_kwargs = None
                self.buf = array.array('B')
                self.expected_length = 6
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 254
                self.little_endian = True
                self.crc_extra = True
                self.sort_fields = True
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                self.startup_time = time.time()

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs

        def set_send_callback(self, callback, *args, **kwargs):
            self.send_callback = callback
            self.send_callback_args = args
            self.send_callback_kwargs = kwargs

        def send(self, mavmsg):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self)
                self.file.write(buf)
                self.seq = (self.seq + 1) % 256
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)
                if self.send_callback:
                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            ret = self.expected_length - len(self.buf)
            if ret <= 0:
                return 1
            return ret

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            if isinstance(c, str):
                self.buf.fromstring(c)
            else:
                self.buf.extend(c)
            self.total_bytes_received += len(c)
            if len(self.buf) >= 1 and self.buf[0] != 254:
                magic = self.buf[0]
                self.buf = self.buf[1:]
                if self.robust_parsing:
                    m = MAVLink_bad_data(chr(magic), "Bad prefix")
                    if self.callback:
                        self.callback(m, *self.callback_args, **self.callback_kwargs)
                    self.expected_length = 6
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic)
            self.have_prefix_error = False
            if len(self.buf) >= 2:
                (magic, self.expected_length) = struct.unpack('BB', self.buf[0:2])
                self.expected_length += 8
            if self.expected_length >= 8 and len(self.buf) >= self.expected_length:
                mbuf = self.buf[0:self.expected_length]
                self.buf = self.buf[self.expected_length:]
                self.expected_length = 6
                if self.robust_parsing:
                    try:
                        m = self.decode(mbuf)
                        self.total_packets_received += 1
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    m = self.decode(mbuf)
                    self.total_packets_received += 1
                if self.callback:
                    self.callback(m, *self.callback_args, **self.callback_kwargs)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                try:
                    magic, mlen, seq, srcSystem, srcComponent, msgId = struct.unpack('cBBBBB', msgbuf[:6])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                if ord(magic) != 254:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-8:
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u' % (len(msgbuf)-8, mlen, msgId))

                if not msgId in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %u' % msgId)

                # decode the payload
                (fmt, type, order_map, len_map, crc_extra) = mavlink_map[msgId]

                # decode the checksum
                try:
                    crc, = struct.unpack('<H', msgbuf[-2:])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crc2 = x25crc(msgbuf[1:-2])
                if True: # using CRC extra
                    crc2.accumulate(chr(crc_extra))
                if crc != crc2.crc:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                try:
                    t = struct.unpack(fmt, msgbuf[6:-2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(msgbuf[6:-2]), emsg))

                tlist = list(t)
                # handle sorted fields
                if True:
                    t = tlist[:]
                    if sum(len_map) == len(len_map):
                        # message has no arrays in it
                        for i in range(0, len(tlist)):
                            tlist[i] = t[order_map[i]]
                    else:
                        # message has some arrays
                        tlist = []
                        for i in range(0, len(order_map)):
                            order = order_map[i]
                            L = len_map[order]
                            tip = sum(len_map[:order])
                            field = t[tip]
                            if L == 1 or isinstance(field, str):
                                tlist.append(field)
                            else:
                                tlist.append(t[tip:(tip + L)])

                # terminate any strings
                for i in range(0, len(tlist)):
                    if isinstance(tlist[i], str):
                        tlist[i] = MAVString(tlist[i])
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-2]
                m._crc = crc
                m._header = MAVLink_header(msgId, mlen, seq, srcSystem, srcComponent)
                return m
        def pose_encode(self, x, y, z, roll, pitch, yaw):
                '''
                Robot pose information.

                x                         : x [mm-sugg.]. (int32_t)
                y                         : y [mm-sugg.]. (int32_t)
                z                         : z [mm-sugg.]. (int32_t)
                roll                      : roll [mrad-sugg.]. (int16_t)
                pitch                     : pitch [mrad-sugg.] (int16_t)
                yaw                       : yaw [mrad-sugg.] (int16_t)

                '''
                msg = MAVLink_pose_message(x, y, z, roll, pitch, yaw)
                msg.pack(self)
                return msg

        def pose_send(self, x, y, z, roll, pitch, yaw):
                '''
                Robot pose information.

                x                         : x [mm-sugg.]. (int32_t)
                y                         : y [mm-sugg.]. (int32_t)
                z                         : z [mm-sugg.]. (int32_t)
                roll                      : roll [mrad-sugg.]. (int16_t)
                pitch                     : pitch [mrad-sugg.] (int16_t)
                yaw                       : yaw [mrad-sugg.] (int16_t)

                '''
                return self.send(self.pose_encode(x, y, z, roll, pitch, yaw))

        def attitude_encode(self, time, roll, pitch, yaw, roll_cmd, pitch_cmd, yaw_cmd, roll_act, pitch_act, yaw_act):
                '''
                Robot attitude information.

                time                      : time [us] (uint32_t)
                roll                      : roll [mrad-sugg.]. (int16_t)
                pitch                     : pitch [mrad-sugg.] (int16_t)
                yaw                       : yaw [mrad-sugg.] (int16_t)
                roll_cmd                  : roll command [mrad-sugg.]. (int16_t)
                pitch_cmd                 : pitch command [mrad-sugg.] (int16_t)
                yaw_cmd                   : yaw command [mrad-sugg.] (int16_t)
                roll_act                  : roll actuator [mV]. (int16_t)
                pitch_act                 : pitch actuator [mV] (int16_t)
                yaw_act                   : yaw actuator [mV] (int16_t)

                '''
                msg = MAVLink_attitude_message(time, roll, pitch, yaw, roll_cmd, pitch_cmd, yaw_cmd, roll_act, pitch_act, yaw_act)
                msg.pack(self)
                return msg

        def attitude_send(self, time, roll, pitch, yaw, roll_cmd, pitch_cmd, yaw_cmd, roll_act, pitch_act, yaw_act):
                '''
                Robot attitude information.

                time                      : time [us] (uint32_t)
                roll                      : roll [mrad-sugg.]. (int16_t)
                pitch                     : pitch [mrad-sugg.] (int16_t)
                yaw                       : yaw [mrad-sugg.] (int16_t)
                roll_cmd                  : roll command [mrad-sugg.]. (int16_t)
                pitch_cmd                 : pitch command [mrad-sugg.] (int16_t)
                yaw_cmd                   : yaw command [mrad-sugg.] (int16_t)
                roll_act                  : roll actuator [mV]. (int16_t)
                pitch_act                 : pitch actuator [mV] (int16_t)
                yaw_act                   : yaw actuator [mV] (int16_t)

                '''
                return self.send(self.attitude_encode(time, roll, pitch, yaw, roll_cmd, pitch_cmd, yaw_cmd, roll_act, pitch_act, yaw_act))

        def velocity_encode(self, time, vx, vy, vz, vx_cmd, vy_cmd, vz_cmd, vx_act, vy_act, vz_act):
                '''
                Robot velocity information.

                time                      : time [us] (uint32_t)
                vx                        : x velocity [mm/s]. (int16_t)
                vy                        : y velocity [mm/s] (int16_t)
                vz                        : z velocity [mm/s] (int16_t)
                vx_cmd                    : x velocity command [mm/s]. (int16_t)
                vy_cmd                    : y velocity command [mm/s] (int16_t)
                vz_cmd                    : z velocity command [mm/s] (int16_t)
                vx_act                    : x velocity actuator [mrad-sugg.]. (int16_t)
                vy_act                    : y velocity actuator [mrad-sugg.]. (int16_t)
                vz_act                    : z velocity actuator [mrad-sugg.]. (int16_t)

                '''
                msg = MAVLink_velocity_message(time, vx, vy, vz, vx_cmd, vy_cmd, vz_cmd, vx_act, vy_act, vz_act)
                msg.pack(self)
                return msg

        def velocity_send(self, time, vx, vy, vz, vx_cmd, vy_cmd, vz_cmd, vx_act, vy_act, vz_act):
                '''
                Robot velocity information.

                time                      : time [us] (uint32_t)
                vx                        : x velocity [mm/s]. (int16_t)
                vy                        : y velocity [mm/s] (int16_t)
                vz                        : z velocity [mm/s] (int16_t)
                vx_cmd                    : x velocity command [mm/s]. (int16_t)
                vy_cmd                    : y velocity command [mm/s] (int16_t)
                vz_cmd                    : z velocity command [mm/s] (int16_t)
                vx_act                    : x velocity actuator [mrad-sugg.]. (int16_t)
                vy_act                    : y velocity actuator [mrad-sugg.]. (int16_t)
                vz_act                    : z velocity actuator [mrad-sugg.]. (int16_t)

                '''
                return self.send(self.velocity_encode(time, vx, vy, vz, vx_cmd, vy_cmd, vz_cmd, vx_act, vy_act, vz_act))

        def position_encode(self, time, x, y, z, x_cmd, y_cmd, z_cmd, x_act, y_act, z_act):
                '''
                Robot position information.

                time                      : time [us] (uint32_t)
                x                         : x [mm-sugg.]. (int32_t)
                y                         : y [mm-sugg.]. (int32_t)
                z                         : z [mm-sugg.]. (int32_t)
                x_cmd                     : x command [mm-sugg.]. (int32_t)
                y_cmd                     : y command [mm-sugg.]. (int32_t)
                z_cmd                     : z command [mm-sugg.]. (int32_t)
                x_act                     : x actuator [mrad]. (int16_t)
                y_act                     : y actuator [mrad] (int16_t)
                z_act                     : z actuator [mrad] (int16_t)

                '''
                msg = MAVLink_position_message(time, x, y, z, x_cmd, y_cmd, z_cmd, x_act, y_act, z_act)
                msg.pack(self)
                return msg

        def position_send(self, time, x, y, z, x_cmd, y_cmd, z_cmd, x_act, y_act, z_act):
                '''
                Robot position information.

                time                      : time [us] (uint32_t)
                x                         : x [mm-sugg.]. (int32_t)
                y                         : y [mm-sugg.]. (int32_t)
                z                         : z [mm-sugg.]. (int32_t)
                x_cmd                     : x command [mm-sugg.]. (int32_t)
                y_cmd                     : y command [mm-sugg.]. (int32_t)
                z_cmd                     : z command [mm-sugg.]. (int32_t)
                x_act                     : x actuator [mrad]. (int16_t)
                y_act                     : y actuator [mrad] (int16_t)
                z_act                     : z actuator [mrad] (int16_t)

                '''
                return self.send(self.position_encode(time, x, y, z, x_cmd, y_cmd, z_cmd, x_act, y_act, z_act))

        def attitude_cmd_encode(self, roll, pitch, yaw, rollFF, pitchFF, yawFF):
                '''
                Robot attitude command/reference.

                roll                      : roll command (int16_t)
                pitch                     : pitch command (int16_t)
                yaw                       : yaw command (int16_t)
                rollFF                    : roll feedforward (int16_t)
                pitchFF                   : pitch feedforward (int16_t)
                yawFF                     : yaw feedforward (int16_t)

                '''
                msg = MAVLink_attitude_cmd_message(roll, pitch, yaw, rollFF, pitchFF, yawFF)
                msg.pack(self)
                return msg

        def attitude_cmd_send(self, roll, pitch, yaw, rollFF, pitchFF, yawFF):
                '''
                Robot attitude command/reference.

                roll                      : roll command (int16_t)
                pitch                     : pitch command (int16_t)
                yaw                       : yaw command (int16_t)
                rollFF                    : roll feedforward (int16_t)
                pitchFF                   : pitch feedforward (int16_t)
                yawFF                     : yaw feedforward (int16_t)

                '''
                return self.send(self.attitude_cmd_encode(roll, pitch, yaw, rollFF, pitchFF, yawFF))

        def velocity_cmd_encode(self, vx, vy, vz, vxFF, vyFF, vzFF):
                '''
                Robot velocity command/reference.

                vx                        : x velocity command (int16_t)
                vy                        : y velocity command (int16_t)
                vz                        : z velocity command (int16_t)
                vxFF                      : x velocity feedforward (int16_t)
                vyFF                      : y velocity feedforward (int16_t)
                vzFF                      : z velocity feedforward (int16_t)

                '''
                msg = MAVLink_velocity_cmd_message(vx, vy, vz, vxFF, vyFF, vzFF)
                msg.pack(self)
                return msg

        def velocity_cmd_send(self, vx, vy, vz, vxFF, vyFF, vzFF):
                '''
                Robot velocity command/reference.

                vx                        : x velocity command (int16_t)
                vy                        : y velocity command (int16_t)
                vz                        : z velocity command (int16_t)
                vxFF                      : x velocity feedforward (int16_t)
                vyFF                      : y velocity feedforward (int16_t)
                vzFF                      : z velocity feedforward (int16_t)

                '''
                return self.send(self.velocity_cmd_encode(vx, vy, vz, vxFF, vyFF, vzFF))

        def position_cmd_encode(self, x, y, z, xFF, yFF, zFF):
                '''
                Robot position command/reference.

                x                         : x command (int32_t)
                y                         : y command (int32_t)
                z                         : z command (int32_t)
                xFF                       : x feedforward (int16_t)
                yFF                       : y feedforward (int16_t)
                zFF                       : z feedforward (int16_t)

                '''
                msg = MAVLink_position_cmd_message(x, y, z, xFF, yFF, zFF)
                msg.pack(self)
                return msg

        def position_cmd_send(self, x, y, z, xFF, yFF, zFF):
                '''
                Robot position command/reference.

                x                         : x command (int32_t)
                y                         : y command (int32_t)
                z                         : z command (int32_t)
                xFF                       : x feedforward (int16_t)
                yFF                       : y feedforward (int16_t)
                zFF                       : z feedforward (int16_t)

                '''
                return self.send(self.position_cmd_encode(x, y, z, xFF, yFF, zFF))

        def radar_cloud_encode(self, x, y):
                '''
                Point cloud information.

                x                         : x [mm-sugg.]. (int32_t)
                y                         : y [mm-sugg.]. (int32_t)

                '''
                msg = MAVLink_radar_cloud_message(x, y)
                msg.pack(self)
                return msg

        def radar_cloud_send(self, x, y):
                '''
                Point cloud information.

                x                         : x [mm-sugg.]. (int32_t)
                y                         : y [mm-sugg.]. (int32_t)

                '''
                return self.send(self.radar_cloud_encode(x, y))

        def radar_line_encode(self, x, y):
                '''
                Line feature.

                x                         : x [mm-sugg.]. (int32_t)
                y                         : y [mm-sugg.]. (int32_t)

                '''
                msg = MAVLink_radar_line_message(x, y)
                msg.pack(self)
                return msg

        def radar_line_send(self, x, y):
                '''
                Line feature.

                x                         : x [mm-sugg.]. (int32_t)
                y                         : y [mm-sugg.]. (int32_t)

                '''
                return self.send(self.radar_line_encode(x, y))

        def signal_sweptsine_encode(self, channels, fmin, fmax, period, amplitude):
                '''
                Message to set sweptsine excitation

                channels                  : Contains the channels which will be excited. (uint16_t)
                fmin                      : Minimum excitation frequency. (float)
                fmax                      : Maximum excitation frequency. (float)
                period                    : period of the excitation (float)
                amplitude                 : amplitude of the excitation (float)

                '''
                msg = MAVLink_signal_sweptsine_message(channels, fmin, fmax, period, amplitude)
                msg.pack(self)
                return msg

        def signal_sweptsine_send(self, channels, fmin, fmax, period, amplitude):
                '''
                Message to set sweptsine excitation

                channels                  : Contains the channels which will be excited. (uint16_t)
                fmin                      : Minimum excitation frequency. (float)
                fmax                      : Maximum excitation frequency. (float)
                period                    : period of the excitation (float)
                amplitude                 : amplitude of the excitation (float)

                '''
                return self.send(self.signal_sweptsine_encode(channels, fmin, fmax, period, amplitude))

        def signal_multisine_encode(self, channels, id, amplitude):
                '''
                Message to set multisine excitation

                channels                  : Contains the channels which will be excited. (uint16_t)
                id                        : Choose a predefined multisine (uint8_t)
                amplitude                 : amplitude of the excitation (float)

                '''
                msg = MAVLink_signal_multisine_message(channels, id, amplitude)
                msg.pack(self)
                return msg

        def signal_multisine_send(self, channels, id, amplitude):
                '''
                Message to set multisine excitation

                channels                  : Contains the channels which will be excited. (uint16_t)
                id                        : Choose a predefined multisine (uint8_t)
                amplitude                 : amplitude of the excitation (float)

                '''
                return self.send(self.signal_multisine_encode(channels, id, amplitude))

        def signal_steppedsine_encode(self, channels, fmin, fmax, period, stepsize, amplitude):
                '''
                Message to set stepped sine excitation

                channels                  : Contains the channels which will be excited. (uint16_t)
                fmin                      : Minimum excitation frequency. (float)
                fmax                      : Maximum excitation frequency. (float)
                period                    : for how many periods the sine should run (uint8_t)
                stepsize                  : frequency step size (float)
                amplitude                 : amplitude of the excitation (float)

                '''
                msg = MAVLink_signal_steppedsine_message(channels, fmin, fmax, period, stepsize, amplitude)
                msg.pack(self)
                return msg

        def signal_steppedsine_send(self, channels, fmin, fmax, period, stepsize, amplitude):
                '''
                Message to set stepped sine excitation

                channels                  : Contains the channels which will be excited. (uint16_t)
                fmin                      : Minimum excitation frequency. (float)
                fmax                      : Maximum excitation frequency. (float)
                period                    : for how many periods the sine should run (uint8_t)
                stepsize                  : frequency step size (float)
                amplitude                 : amplitude of the excitation (float)

                '''
                return self.send(self.signal_steppedsine_encode(channels, fmin, fmax, period, stepsize, amplitude))

        def channel_io_encode(self, time, sync, input, output):
                '''
                Message to send input-output channel information to the ground station

                time                      : TimeStamp (uint32_t)
                sync                      : Synchronization value (uint8_t)
                input                     : Input to the channel (float)
                output                    : Output of the channel (float)

                '''
                msg = MAVLink_channel_io_message(time, sync, input, output)
                msg.pack(self)
                return msg

        def channel_io_send(self, time, sync, input, output):
                '''
                Message to send input-output channel information to the ground station

                time                      : TimeStamp (uint32_t)
                sync                      : Synchronization value (uint8_t)
                input                     : Input to the channel (float)
                output                    : Output of the channel (float)

                '''
                return self.send(self.channel_io_encode(time, sync, input, output))

        def channel_io_info_encode(self, type, configuration, excitation, version, subversion):
                '''
                Info regarding channel io

                type                      : Type of excitation: stepped sine, sweptsine, multisine,... (uint8_t)
                configuration             : Which inputs and outputs are selected. Choose one out of many default configurations (uint8_t)
                excitation                : Which channels where excited (uint8_t)
                version                   : log file version (uint8_t)
                subversion                : log file version (uint8_t)

                '''
                msg = MAVLink_channel_io_info_message(type, configuration, excitation, version, subversion)
                msg.pack(self)
                return msg

        def channel_io_info_send(self, type, configuration, excitation, version, subversion):
                '''
                Info regarding channel io

                type                      : Type of excitation: stepped sine, sweptsine, multisine,... (uint8_t)
                configuration             : Which inputs and outputs are selected. Choose one out of many default configurations (uint8_t)
                excitation                : Which channels where excited (uint8_t)
                version                   : log file version (uint8_t)
                subversion                : log file version (uint8_t)

                '''
                return self.send(self.channel_io_info_encode(type, configuration, excitation, version, subversion))

        def heartbeat_encode(self, type, time, data, mavlink_version=2):
                '''
                The heartbeat message shows that a system is present and responding.
                The type of the MAV and Autopilot hardware allow the
                receiving system to treat further messages from this
                system appropriate (e.g. by laying out the user
                interface based on the autopilot).

                type                      : Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM) (uint8_t)
                time                      : Onboard time (uint32_t)
                data                      : 8 data bytes to send whatever you want. (uint8_t)
                mavlink_version           : MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version (uint8_t)

                '''
                msg = MAVLink_heartbeat_message(type, time, data, mavlink_version)
                msg.pack(self)
                return msg

        def heartbeat_send(self, type, time, data, mavlink_version=2):
                '''
                The heartbeat message shows that a system is present and responding.
                The type of the MAV and Autopilot hardware allow the
                receiving system to treat further messages from this
                system appropriate (e.g. by laying out the user
                interface based on the autopilot).

                type                      : Type of the MAV (quadrotor, helicopter, etc., up to 15 types, defined in MAV_TYPE ENUM) (uint8_t)
                time                      : Onboard time (uint32_t)
                data                      : 8 data bytes to send whatever you want. (uint8_t)
                mavlink_version           : MAVLink version, not writable by user, gets added by protocol because of magic data type: uint8_t_mavlink_version (uint8_t)

                '''
                return self.send(self.heartbeat_encode(type, time, data, mavlink_version))

        def thread_info_encode(self, time, ID, priority, duration, latency, total_duration, total_latency, number_of_executions):
                '''
                Message to report the execution time of the threads up till moment t
                [us].

                time                      : Onboard time. (uint32_t)
                ID                        : Thread ID. (uint8_t)
                priority                  : Get the priority of the thread. (uint8_t)
                duration                  : get last duration [us]. (uint16_t)
                latency                   : get last latency [us]. (uint16_t)
                total_duration            : total duration counter: used to compute the average duration [us]. (uint32_t)
                total_latency             : total latency counter: used to compute the average latency [us]. (uint32_t)
                number_of_executions        : number of executions of the thread. (uint32_t)

                '''
                msg = MAVLink_thread_info_message(time, ID, priority, duration, latency, total_duration, total_latency, number_of_executions)
                msg.pack(self)
                return msg

        def thread_info_send(self, time, ID, priority, duration, latency, total_duration, total_latency, number_of_executions):
                '''
                Message to report the execution time of the threads up till moment t
                [us].

                time                      : Onboard time. (uint32_t)
                ID                        : Thread ID. (uint8_t)
                priority                  : Get the priority of the thread. (uint8_t)
                duration                  : get last duration [us]. (uint16_t)
                latency                   : get last latency [us]. (uint16_t)
                total_duration            : total duration counter: used to compute the average duration [us]. (uint32_t)
                total_latency             : total latency counter: used to compute the average latency [us]. (uint32_t)
                number_of_executions        : number of executions of the thread. (uint32_t)

                '''
                return self.send(self.thread_info_encode(time, ID, priority, duration, latency, total_duration, total_latency, number_of_executions))

        def partition_encode(self, ID, index, size, togo, value):
                '''
                Message to read the entire eeprom.

                ID                        : Partition ID - make this a general purpose message (char)
                index                     : First register that was read out. (uint16_t)
                size                      : Holds how many bytes are of importance, begining from index. (uint8_t)
                togo                      : Holds how many partitions are still to come. If togo = 0, the last message was received. (uint8_t)
                value                     : Values of the 32 fields, starting from the indicated register (uint8_t)

                '''
                msg = MAVLink_partition_message(ID, index, size, togo, value)
                msg.pack(self)
                return msg

        def partition_send(self, ID, index, size, togo, value):
                '''
                Message to read the entire eeprom.

                ID                        : Partition ID - make this a general purpose message (char)
                index                     : First register that was read out. (uint16_t)
                size                      : Holds how many bytes are of importance, begining from index. (uint8_t)
                togo                      : Holds how many partitions are still to come. If togo = 0, the last message was received. (uint8_t)
                value                     : Values of the 32 fields, starting from the indicated register (uint8_t)

                '''
                return self.send(self.partition_encode(ID, index, size, togo, value))

        def gpio_encode(self, time, gpio_float, gpio_int):
                '''
                Message to send debugging information

                time                      : Time at which the message was sent. (uint32_t)
                gpio_float                : 8 gpio floating point values (float)
                gpio_int                  : 4 gpio integer values (int32_t)

                '''
                msg = MAVLink_gpio_message(time, gpio_float, gpio_int)
                msg.pack(self)
                return msg

        def gpio_send(self, time, gpio_float, gpio_int):
                '''
                Message to send debugging information

                time                      : Time at which the message was sent. (uint32_t)
                gpio_float                : 8 gpio floating point values (float)
                gpio_int                  : 4 gpio integer values (int32_t)

                '''
                return self.send(self.gpio_encode(time, gpio_float, gpio_int))

        def event_encode(self, type):
                '''
                Message to send event information: can be external event from base or
                event on robot

                type                      : Event identifier. 0-1000 are reserved for microOS. User-specific events should be higher than 1000. (uint16_t)

                '''
                msg = MAVLink_event_message(type)
                msg.pack(self)
                return msg

        def event_send(self, type):
                '''
                Message to send event information: can be external event from base or
                event on robot

                type                      : Event identifier. 0-1000 are reserved for microOS. User-specific events should be higher than 1000. (uint16_t)

                '''
                return self.send(self.event_encode(type))

        def print_encode(self, text):
                '''
                Message allowing short strings to be passed on.

                text                      : Text to be sent. We suggest termination with '\0'. (char)

                '''
                msg = MAVLink_print_message(text)
                msg.pack(self)
                return msg

        def print_send(self, text):
                '''
                Message allowing short strings to be passed on.

                text                      : Text to be sent. We suggest termination with '\0'. (char)

                '''
                return self.send(self.print_encode(text))

